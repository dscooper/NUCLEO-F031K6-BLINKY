# NUCLEO-F031K6 Blinky

- [NUCLEO-F031K6 Blinky](#nucleo-f031k6-blinky)
  - [Introduction](#introduction)
  - [The Devil Is In The Details](#the-devil-is-in-the-details)
  - [Some Additional Comments On The Linker](#some-additional-comments-on-the-linker)
    - [Simplified Linker Overview](#simplified-linker-overview)
      - [Special Sections](#special-sections)
  - [Additional References](#additional-references)
  - [Footnotes](#footnotes)

## Introduction

This is another 'blinky' application, a follow up to a previous example that
demonstrated a bare bones, bare metal embedded application based on the
STMicroelectronics STM32F401RE ARM Cortex M4 microcontroller.

The previous blinky example was developed on the NUECEO-F401RE evaluation board.
That MCU is a much more feature rich processor. This example is based on the
much smaller SMT32F031K6, the MCU on the NUCLEO-F031K6 evaluation board. 
    
The STM32F031K6 has the following features:

- ARM Cortex M0
- 32Kb Flash
- 4Kb Static Ram
- No FPU

Far fewer resources than the STM32F401RE.

While the reduced memory footprint and instruction set is significant, the lack
of floating-point unit (FPU) brings with it some interesting challenges that
will be developed later.

The previous example was developed with the **arm-none-eabi-*** toolchain that
is bundled with **STM32CubeMX**. I suspect that most ARM Cortex-M toolchains can
be used here, perhaps with some modification, but cannot guarantee it.

Some differences in this example include

- no dependency on HAL code
- start up code is in C, no assembly code

The last bullet point is what differentiates this project from the last. That
and developing a new linker script instead of using one generated by
**STM32CubeMX**. 

Note that the use of the CMSIS-Core Device Files [^1] is not really followed
here with the exception of the all C startup code. The example is just too
small.

<!-- The Devil is in the Details ------------------------------------------- -->
## The Devil Is In The Details

There are a few things to note in the arguments passed to the linker. See the
linker file for the following discussion

- libgcc (LFLAGS   += -nostdlib -lgcc)
  
  Removing the linker flag -lgcc will make the link stage fail with the
  following error:

  ~~~
  systick.c:41: undefined reference to `__aeabi_uidiv'
  ~~~
     
  There is no hardware support for division so it is handled in software.
  Division is handled by a library call to ARM's version of **libgcc.a**. You
  will want the library specific for **armv6-m** architecture.

  If we remove the **-march=armv6-m** from the linker flags the wrong
  **libgcc.a** gets linked into the project and the code throws an exception at
  **SysTick_Config()** only this time the compiler didn't warn us.

  A look at the map file tells the story.

  ~~~
  < ../lib/gcc/arm-none-eabi/12.3.1/thumb/v6-m/nofp/libgcc.a(_udivsi3.o)
  ---
  > ../lib/gcc/arm-none-eabi/12.3.1/thumb/nofp/libgcc.a(_udivsi3.o)
  ~~~

  The first line is from the map file with the working code - the file linked
  with **-march=armv6-m**. The second line is from the file **NOT** linked with
  **-march=armv6-m**. The difference is we're now linking **libgcc.a** for the
  Arm v6-M architecture, not generic architecture. 

  Note that order of the arguments is **important**!

  ~~~
  LFLAGS    = -mtune=cortex-m0 -march=armv6-m -mthumb
  ~~~

  will work but

  ~~~
  LFLAGS    = -mthumb -mtune=cortex-m0 -march=armv6-m 
  ~~~

  will not.

- -nostdlib (LFLAGS   += -nostdlib -lgcc)

  Removing the linker flag **-nostdlib** will not make the link stage fail but
  the program will run erratically. The effect of removing this linker flag is
  that libc is now included and several functions (e.g., stdio) from that
  library are seemingly included then discarded. The bottom line, at least on my
  platform, is that the **SysTick_Handler()** runs significantly slower and gdb
  is problematic.

  Seeing how there is little use for the standard library in this case we'll
  drop it. However for those interested a look at the map file is interesting.

- -nostartup (LFLAGS   += -nostartfiles)  

  This is an alternative to the linking options **-nostdlib -lgcc**. This flag
  correctly links in the **aeabi_** math functions, without specifying **-lgcc**.

<!-- Some Additional Comments On The Linker -------------------------------- -->
## Some Additional Comments On The Linker    

### Simplified Linker Overview

Generally, programs are made up of more than one object file. Regardless, each
object file has code and data grouped in units called sections. For each object
file the beginning address of section usually starts at zero. The assembler, the
usual creator of the object files, doesn't know where the code and data will be
placed in memory so these sections are called 'relocatable' and their absolute
addresses are determined by the linker. 

One purpose of the linker is basically to take all the relocatable sections and
coalesce like sections (e.g., code) together and fix up the addresses to produce
the final binary executable for microcontrollers, like the ones here. 

This explanation paints with a very broad brush, glossing over many details and
leaving out many others, but hopefully gives you an idea for what the linker is
used for in this context.

#### Special Sections

In the ELF file format there several are special sections. A review of the more
common ones is below.

| Name    | Description                                     |
| :---:   | :---                                            |
|.text    | holds the executable instructions of a program  |
|.data    | initialized data                                |
|.bss     | uninitialized data                              |
|.comment | version control information                     |

These are not the only sections of course but these are common to most object
files.

As an example, a simple C code module will be created and compiled to an object
file. The example below would not create an executable binary because  the 
function **_write** is defined elsewhere. It is not defined for this example.

~~~c
//
// Compiled with: arm-none-eabi-gcc -march=armv6-m -mcpu=cortex-m0 -mthumb -c main.c -o main.o
//
extern int _write(int file, char *ptr, int len);

static char string[] = "Hello, World!";
static char* ptr = string;

int results;

int main(void)
{
  results = _write(1, ptr, sizeof(string));
  return 0;
}
~~~

Dump the symbol table using objdump

~~~
$ arm-none-eabi-objdump -t main.o

main.o:     file format elf32-littlearm

SYMBOL TABLE:
00000000 l    df *ABS*	00000000 main.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l     O .data	0000000e string
00000010 l     O .data	00000004 ptr
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     O .bss	00000004 results
00000000 g     F .text	00000028 main
00000000         *UND*	00000000 _write
~~~

The details on how to interpret the symbol table can be found at the GNU binary
utilities (GNU Binutils) web site[^2]. 

## Additional References

- Documents the internals of the GNU compilers <br>
  https://gcc.gnu.org/onlinedocs/gccint/

- 3.16 Options for Linking <br>
  https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html

- 3.19.5 ARM Options <br>
  https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/ARM-Options.html

## Footnotes

[^1]: https://arm-software.github.io/CMSIS_6/latest/Core/index.html
[^2]: https://sourceware.org/binutils/docs/binutils/objdump.html
